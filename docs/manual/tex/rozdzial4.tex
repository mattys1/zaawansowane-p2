	\newpage
\section{Implementacja}		%4
%Opisać implementacje algorytmu/programu. Pokazać ciekawe fragmenty kodu
%Opisać powstałe wyniki (algorytmu/nrzędzia)

\subsection{Ogólne informacje o implementacji klasy}

Drzewo jest zaimplementowane jako jeden plik \texttt{.hpp}. Nie jest podzielone na plik implementacji oraz nagłówek, ponieważ jest ono szablonem. Deklaracja klasy oraz prywatne elementy wyglądają następująco:

\begin{lstlisting}[caption=Deklaracja drzewa BST, label={lst:BSTprivate}, language=C++]
	template <typename T>
	class BSTTree {
		private:
		struct Tree {
			T contents;
			Tree* parent;
			Tree* left;
			Tree* right;
			
			Tree(T _contents, Tree* _parent = nullptr, Tree* _left = nullptr, Tree* _right = nullptr):
			contents { _contents },
			parent { _parent },
			left { _left },
			right { _right } {}
			
			~Tree() {
				delete left;
				delete right;
			}
		};
		
		Tree* root;
		
		void recursive_add(const T& element, Tree*& node, Tree* parentNode = nullptr) {
			if(node == nullptr) {
				node = new Tree(element);
				
				if(parentNode == nullptr) {
					return;
				}
				
				node->parent = parentNode;
				
				if(node->contents >= parentNode->contents) {
					parentNode->right = node;
				} else {
					parentNode->left = node;
				}
				
				return;
			}
			
			if(element >= node->contents) {
				recursive_add(element, node->right, node);
			} else {
				recursive_add(element, node->left, node);
			}	
		}
		
		void preorder_traverse_recursive(Tree* node, std::vector<Tree*>& traversedTrees) {
			if(node == nullptr) {
				return;
			}
			
			traversedTrees.push_back(node);
			
			preorder_traverse_recursive(node->left, traversedTrees);
			preorder_traverse_recursive(node->right, traversedTrees);
		}
		
		void inorder_traverse_recursive(Tree* node, std::vector<Tree*>& traversedTrees) {
			if(node == nullptr) {
				return;
			}
			
			inorder_traverse_recursive(node->left, traversedTrees);
			
			traversedTrees.push_back(node);
			
			inorder_traverse_recursive(node->right, traversedTrees);
		}
		
		void postorder_traverse_recursive(Tree* node, std::vector<Tree*>& traversedTrees) {
			if(node == nullptr) {
				return;
			}
			
			postorder_traverse_recursive(node->left, traversedTrees);
			postorder_traverse_recursive(node->right, traversedTrees);
			
			traversedTrees.push_back(node);
		}
		public:
		...
\end{lstlisting}

Jak widać w kodzie zamieszczonym na listingu nr. \ref{lst:BSTprivate}., Klasa jest wrapperem dla structa \texttt{Tree}, zadeklarowanego na linijce nr. 4. Struct ten ma trzy wskaźniki - \texttt{left} dla elementu lewego, \texttt{right} dla elementu prawego, \texttt{parent} dla elementu będącego rodzicem oraz zawartość \texttt{contents}, opsującą element zawarty w danym węźle. 

W linii 10 zadeklarowany jest konstruktor, który domyślnie ustawia wartości wskaźników rodzica, dziecka lewego oraz prawego na \texttt{nullptr}. Istnieje możliwość sprecyzowania wartości wskaźników.

Od linii 16 do 18 znajduje się destruktor drzewa. W destruktorze węzeł lewy i prawy jest usuwany.

\subsection{Ciekawe fragmenty kodu}
