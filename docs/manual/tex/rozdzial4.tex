	\newpage
\section{Implementacja}		%4
%Opisać implementacje algorytmu/programu. Pokazać ciekawe fragmenty kodu
%Opisać powstałe wyniki (algorytmu/nrzędzia)

\subsection{Ogólne informacje o implementacji klasy}

Drzewo jest zaimplementowane jako jeden plik \texttt{.hpp}. Nie jest podzielone na plik implementacji oraz nagłówek, ponieważ jest ono szablonem. Deklaracja klasy oraz prywatne elementy wyglądają następująco:

\begin{lstlisting}[caption=Deklaracja drzewa BST, label={lst:BSTprivate}, language=C++]
	template <typename T>
	class BSTTree {
		private:
		struct Tree {
			T contents;
			Tree* parent;
			Tree* left;
			Tree* right;
			
			Tree(T _contents, Tree* _parent = nullptr, Tree* _left = nullptr, Tree* _right = nullptr):
			contents { _contents },
			parent { _parent },
			left { _left },
			right { _right } {}
			
			~Tree() {
				delete left;
				delete right;
			}
		};
		
		Tree* root;
		
		void recursive_add(const T& element, Tree*& node, Tree* parentNode = nullptr) {
			if(node == nullptr) {
				node = new Tree(element);
				
				if(parentNode == nullptr) {
					return;
				}
				
				node->parent = parentNode;
				
				if(node->contents >= parentNode->contents) {
					parentNode->right = node;
				} else {
					parentNode->left = node;
				}
				
				return;
			}
			
			if(element >= node->contents) {
				recursive_add(element, node->right, node);
			} else {
				recursive_add(element, node->left, node);
			}	
		}
		
		void preorder_traverse_recursive(Tree* node, std::vector<Tree*>& traversedTrees) {
			if(node == nullptr) {
				return;
			}
			
			traversedTrees.push_back(node);
			
			preorder_traverse_recursive(node->left, traversedTrees);
			preorder_traverse_recursive(node->right, traversedTrees);
		}
		
		void inorder_traverse_recursive(Tree* node, std::vector<Tree*>& traversedTrees) {
			if(node == nullptr) {
				return;
			}
			
			inorder_traverse_recursive(node->left, traversedTrees);
			
			traversedTrees.push_back(node);
			
			inorder_traverse_recursive(node->right, traversedTrees);
		}
		
		void postorder_traverse_recursive(Tree* node, std::vector<Tree*>& traversedTrees) {
			if(node == nullptr) {
				return;
			}
			
			postorder_traverse_recursive(node->left, traversedTrees);
			postorder_traverse_recursive(node->right, traversedTrees);
			
			traversedTrees.push_back(node);
		}
		public:
		...
\end{lstlisting}

Jak widać w kodzie \ref{lst:BSTprivate}., Klasa jest wrapperem dla structa \texttt{Tree}. Struct ten ma trzy wskaźniki - \texttt{left} dla elementu lewego, \texttt{right} dla elementu prawego, \texttt{parent} dla elementu będącego rodzicem oraz zawartość \texttt{contents} nie będącą wskaźnikiem. W linii 10 znajduje się konstruktor, który ustawia wartości wskaźników rodzica, dziecka lewego oraz prawego na null.
Od linii 11 do 14 jest konstruktor który pozwala ustawić wskaźniki i wymaga ustawienia zawartości.
Od linii 16 do 18 znajduje się destruktor drzewa. W destruktorze węzeł lewy i prawy jest usuwany.

Manipulacje strukturą listy odbywają się poprzez szereg metod publicznych. Wiele z nich posiada podobną strukturę. Za przykład jednej z nich można wziąć \texttt{prepend()}:

\begin{lstlisting}[caption = Kod \texttt{prepend()}, label={lst:prepend}, language=C++]
	void prepend(const T& item) {
		if(head == nullptr) {
			head = new Node { nullptr, nullptr, item };	
			tail = head;
			return;
		}

		head = new Node { nullptr, head, item };
		head->next->previous = head;
	}
\end{lstlisting}

Metoda z fragmentu nr. \ref{lst:prepend} ma na celu wstawienie elementu, którego wartość jest zawarta w parametrze \texttt{item} na początku listy. Na początku metody, sprawdzane jest czy lista jest pusta - wtedy \texttt{head == nullptr}. Jeżeli jest, trzeba stworzyć nowego \texttt{Node} na miejscu heada z zawartością będąca parametrem \texttt{item}. Jeżeli \texttt{head} już istnieje, to też tworzy się nowego \texttt{Nodea} na jego miejscu, lecz jako wskaźnik \texttt{next} ustawia się adres starego \texttt{heada}. Potem we wskaźniku \texttt{previous} starego \texttt{heada} ustawia się adres nowego heada. Ten zabieg efektywnie sprawił ze stary \texttt{head} jest drugi w kolejności listy.

\subsection{Ciekawe fragmenty kodu}

W metodzie \texttt{pop\_at()}, mającej na celu usuniecie \texttt{Nodea} o danym indeksie, wywoływany jest destruktor danego \texttt{Nodea} w taki sposób, aby - ze względu na jego rekursywny charakter - nie usuwać następnych elementów listy. Przy czym ciągłość listy musi być zachowana. Kod metody wygląda następująco:

\begin{lstlisting}[caption=Kod \texttt{pop\_at()}, label={lst:popat}, language=C++]

	void pop_at(size_t index) {
		Node* toPop { get_node_at(index) };
		if(toPop == head) {
			rpop();
			return;
		} else if(toPop == tail) {
			pop();
			return;
		}

		toPop->previous->next = toPop->next;
		toPop->next->previous = toPop->previous;
		toPop->next = nullptr;

		delete toPop;
	}

\end{lstlisting}

Jak widać na fragmencie nr. \ref{lst:popat}, takie zabiegi wymagają niezłej zabawy ze wskaźnikami. 
